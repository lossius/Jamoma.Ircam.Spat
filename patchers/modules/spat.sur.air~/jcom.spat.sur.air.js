// Javascript for Jamoma: scripting algorithm for creating air filter.// Number of instances changed dynamically depending on number of sources used.//// By Trond Lossius, ï¿½2006// License: GNU LGPL/******************************************************************* * SETUP *******************************************************************/autowatch = 1;// CONSTANTSMAX_SOURCES = 32;					// Maximum number of speakers// VARIABLESvar sampleRate = 44100;var DSPRunning = 0;var distance = new Array(MAX_SOURCES);var numSources = 0;					// Current number of sourcesvar numSourcesPrevious = 0;			// Previous number of sourcesvar holdSources = 0;				// If audio is running, the number of sources will not be changed									// Instead the message is held until audio is turned offvar holdFlag = 0;					// Flag indicating if change in number of sources 									// is currently on holdvar i								// A counter// INLETS AND OUTLETSoutlets = 0;setinletassist(0,"Number of sources, DSP state");setoutletassist(0,"Scripting messages");function dspstate(value){	DSPRunning = value;		if (value==0)	{		if (holdFlag==1)			sources(holdSources);	}}// javascript in Max doesn't fancy camelcase, so we use numsources rather than numSourcesfunction numsources(value){	// Put change in number of sources on hold if audio is running	if (DSPRunning==1)	{		holdSources = value;		holdFlag = 1;				post("jmod.spat.sur.air~: Audio is currently running.");		post();		post("Number of sources will be updated next time audio is turned off.");		post();	}		else	{			// Only perform scripting if the number of sources actually change		if (value==numSources) return;			numSourcesPrevious = numSources;		numSources = value;				if (numSources > MAX_SOURCES)			numSources = MAX_SOURCES;		if (numSources < 0)			numSources = 0;				for (i=0; i<numSourcesPrevious; i++)		{			outlet(0, "script", "delete", "spat.air["+(i+1)+"]");		}		for (i=0; i<numSources; i++)		{			outlet(0, "script", "new", "spat.air["+(i+1)+"]", "newex", (80+40*i), (220+25*i), 73, 196617, "spat.air~");			outlet(0, "script", "connect", "multiout", i, "spat.air["+(i+1)+"]", 0);			outlet(0, "script", "connect", "spat.air["+(i+1)+"]", 0, "multiin", i);			outlet(0, "script", "connect", "route", i, "spat.air["+(i+1)+"]", 0);		}	}}